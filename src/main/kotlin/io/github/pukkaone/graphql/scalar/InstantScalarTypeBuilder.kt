package io.github.pukkaone.graphql.scalar

import com.google.auto.service.AutoService
import graphql.GraphQLContext
import graphql.execution.CoercedVariables
import graphql.language.ScalarTypeDefinition
import graphql.language.StringValue
import graphql.language.Value
import graphql.schema.Coercing
import graphql.schema.CoercingParseLiteralException
import graphql.schema.CoercingParseValueException
import graphql.schema.CoercingSerializeException
import graphql.schema.GraphQLScalarType
import java.time.DateTimeException
import java.time.Instant
import java.time.format.DateTimeFormatterBuilder
import java.time.format.DateTimeParseException
import java.util.Locale

private const val SECOND_FRACTIONAL_DIGITS = 3
private val INSTANT_FORMATTER = DateTimeFormatterBuilder().appendInstant(SECOND_FRACTIONAL_DIGITS).toFormatter()

private val COERCING = object : Coercing<Instant, String> {

    override fun serialize(input: Any, context: GraphQLContext, locale: Locale): String {
        if (input is Instant) {
            try {
                return INSTANT_FORMATTER.format(input)
            } catch (e: DateTimeException) {
                throw CoercingSerializeException("Cannot format Instant $input", e)
            }
        } else {
            throw CoercingSerializeException("Expected value of type Instant but was ${input.javaClass}")
        }
    }

    override fun parseValue(input: Any, context: GraphQLContext, locale: Locale): Instant {
        return when (input) {
            is Instant ->
                input

            is String ->
                try {
                    Instant.parse(input.toString())
                } catch (e: DateTimeParseException) {
                    throw CoercingParseValueException("Cannot parse [$input] to Instant", e)
                }

            else ->
                throw CoercingParseValueException("Expected input value of type String but was ${input.javaClass}")
        }
    }

    override fun parseLiteral(
        input: Value<*>,
        variables: CoercedVariables,
        context: GraphQLContext,
        locale: Locale,
    ): Instant {
        if (input is StringValue) {
            try {
                return Instant.parse(input.value)
            } catch (e: DateTimeParseException) {
                throw CoercingParseLiteralException("Cannot parse [$input] to Instant", e)
            }
        } else {
            throw CoercingParseLiteralException("Expected literal of type StringValue but was ${input.javaClass}")
        }
    }
}

/**
 * Custom GraphQL scalar type that accepts strings formatted like yyyy-MM-dd'T'HH:mm:ss.SSS'Z'
 * and produces java.time.Instant objects at runtime.
 */
@AutoService(GraphQLScalarTypeBuilder::class)
class InstantScalarTypeBuilder : GraphQLScalarTypeBuilder {

    override fun build(): GraphQLScalarType {
        return GraphQLScalarType.newScalar()
            .name(Instant::class.simpleName)
            .description(
                "Date and time in UTC time zone as typically generated by a machine. " +
                    "Value is a string formatted as yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
            )
            .definition(
                ScalarTypeDefinition.newScalarTypeDefinition()
                    .name(Instant::class.simpleName)
                    .build()
            )
            .coercing(COERCING)
            .build()
    }
}
